{"version":3,"file":"DocumentUploader-e2ec1a13.js","sources":["../../src/services/DocumentCategoryService.ts","../../src/services/DocumentOcrService.ts","../../src/components/DocumentUploader/DocumentUploader.tsx"],"sourcesContent":["import BaseApiService from \"./BaseApiService\";\n\nconst DEFAULT_PATH = \"/custom/api/document/category/search\";\n\nclass DocumentCategoryService extends BaseApiService {\n  getDocumentCategory = (start = 0, limit = 10, search: string) => {\n    const url = `${DEFAULT_PATH}?isActive=true&start=${start}&limit=${limit}&category.code=${search}`;\n    return this.makeGetRequestWithAuth(url);\n  };\n}\n\nexport default new DocumentCategoryService();\n","import BaseApiService from \"./BaseApiService\";\n\nconst DEFAULT_PATH = \"/custom/api\";\n\nclass DocumentOcrService extends BaseApiService {\n  populateUsingOcr(payload: any, search: string) {\n    const url = `${DEFAULT_PATH}/${search}/loan/document/ocr`;\n    return this.makePostRequestWithAuth(url, payload);\n  }\n}\n\nexport default new DocumentOcrService();\n","import LoaderIcon from \"assets/img/buttonIcons/loader.png\";\nimport AutoComplete from \"components/AutoComplete/AutoComplete\";\nimport ButtonBox from \"components/ButtonBox\";\nimport DatePicker from \"components/DatePicker\";\nimport ErrorDialog from \"components/ErrorDialog\";\nimport FileUploadCustom, { IFileUploadCustomRef, IUploadedFile } from \"components/FileUploadCustom\";\nimport FileUploadMenuBox from \"components/FileUploadMenuBox/FileUploadMenuBox\";\nimport IconButton, { BUTTON_TYPES } from \"components/IconButton\";\nimport InputBox from \"components/InputBox\";\nimport { IMediaInfo } from \"components/MediaGallery/MediaGallery\";\nimport SimpleDropDown from \"components/SimpleDropDown\";\nimport Text from \"components/Text\";\nimport { IDropDownOption } from \"interface/component\";\nimport { CalendarChangeParams } from \"primereact/calendar\";\nimport { DropdownChangeParams } from \"primereact/dropdown\";\nimport React, {\n  BaseSyntheticEvent,\n  Fragment,\n  ReactNode,\n  forwardRef,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from \"react\";\nimport DocumentCategoryService from \"services/DocumentCategoryService\";\nimport DocumentOcrService from \"services/DocumentOcrService\";\nimport DocumentService from \"services/DocumentService\";\nimport StaticMasterDataService from \"services/masterdata/StaticMaster/StaticMasterDataService\";\nimport SimpleReactValidator from \"simple-react-validator\";\nimport {\n  getStandardValidator,\n  messageReplace,\n  parseStandardAPIErrorMessage,\n  validateGetAPIResponse,\n  validatePostAPIResponse,\n} from \"utils/CommonUtil\";\nimport { BUTTON_TYPE, DOCUMENT_CATEGORY, DOCUMENT_SECTION, INPUT_STYLE_TYPE } from \"utils/Constant\";\n\n/*------------------interfaces & types----------------- */\n\ninterface IDocument {\n  uid: string;\n  label: string;\n  value: string;\n  isActive: boolean;\n  hasDocumentNumber: boolean | undefined;\n  isMultiFileAllowedPerSection: boolean | undefined;\n}\n\nexport interface IAttributeConfig {\n  dataType: string;\n  inputType: string;\n  label: string;\n  name: string;\n  required: boolean;\n  isPrimaryAttribute: boolean;\n}\n\nexport interface ISavedDocumentRecords {\n  listKey?: string; // used only for \"key\" prop while rendering document uploader in a list\n  uid: string; // saved document object uid\n  attributes: { [key: string]: string | number | Date };\n  dob?: Date;\n  docCategory: string;\n  docFor?: string | null;\n  docNo?: string | number;\n  docType: { [key: string]: any };\n  documentSections: ISavedDocumentSections[];\n  loanSectionKey?: string;\n  maskedDocNo?: string;\n  isActive: boolean;\n}\n\nexport interface ISavedDocumentSections {\n  uid: string;\n  fileName: string;\n  fileType: string;\n  isActive: boolean;\n  section: string;\n  sectionName: string;\n  thumbUrl: string;\n  url: string;\n  meta?: string;\n}\n\ninterface IDocumentAttribute {\n  docCode: string;\n  attributes: IAttributeConfig[];\n  primaryKey: string;\n}\n\ninterface IDocDropdownInfo {\n  documentTypeList: IDocument[];\n  selectedDocType: string;\n}\n\nexport interface IUploadedDocumentSection extends IUploadedFile {\n  uid?: string | null;\n  name?: string;\n  code?: string;\n  isActive: boolean;\n  [key: string]: any;\n}\nexport interface IDocumentInfo {\n  uid?: string | null; //saved document uid\n  primaryKeyAttributeName?: string; // attribute field which has isPrimarykey value as true in document type attributes\n  documentUid: string;\n  documentName: string;\n  documentCode: string;\n  documentCategory: string;\n  documentSectionUrls: IUploadedDocumentSection[];\n  isActive: boolean;\n  [key: string]: any;\n}\n\ninterface IDocumentUploaderAutocomplete {\n  uid: string;\n  name: string;\n  code: string;\n}\n\nexport interface IOcrPayloadData {\n  loanUid: string;\n  applicant: {\n    uid: string;\n  };\n}\nexport interface IOCR {\n  showPopulateOcr: boolean;\n  enableOcr: boolean;\n}\nexport interface IDocUploaderOCRStatus {\n  success: boolean;\n  failed: boolean;\n}\n\nexport interface IOcrResponse {\n  uid: string;\n  maskedDocNo: string | null;\n  docNo: string;\n  dob: string | null;\n  meta: { [key: string]: any };\n  attributes: { [key: string]: any };\n  documentSections: { uid: string; sectionName: string }[];\n}\n\ninterface IDocumentUploaderProps {\n  mode: string;\n  queryParamForDocList: string;\n  docUploadTypeTitle?: string;\n  savedDocument?: ISavedDocumentRecords;\n  ocrStageName?: string;\n  ocrSubstageName?: string;\n  ocrPayloadData?: IOcrPayloadData;\n  mandatoryDocUpload?: boolean;\n  accessKebab?: boolean;\n  docUploaderIndex?: number;\n  onRemoveFromList?: (uploadInfo: IDocumentInfo, idx: number) => void;\n}\n\ntype ViewMode = \"VIEW\";\ntype EditMode = \"EDIT\";\n\nexport const FILE_UPLOADER_MODE: { mode: ViewMode } = {\n  mode: \"VIEW\",\n};\nexport interface IDocumentUploaderRef {\n  getUploadedData: () => IDocumentInfo | undefined;\n  resetValidator: () => void;\n  resetDocUpload: () => void;\n}\n\n/*-----------------------------globals---------------------------- */\n\nexport const DOC_UPLOADER_MODE: { VIEW: ViewMode; EDIT: EditMode } = {\n  VIEW: \"VIEW\",\n  EDIT: \"EDIT\",\n};\n\nconst INPUT_FIELDS_ATTRIBUTE_NAME = {\n  MASKEDNO: \"maskedNo\",\n  DOB: \"dob\",\n};\n\nconst DOCUMENT_INPUT_FIELDS_TYPE = {\n  DATE: \"date\",\n  TEXT: \"text\",\n  NUMBER: \"number\",\n  SEARCH: \"search\",\n};\n\nconst DOCUMENT_UPLOAD_CATEGORY_LABEL: { [key: string]: string } = {\n  DOCUMENT_CATEGORY_ADDRESS_PROOF: \"ADDRESS PROOF\",\n  DOCUMENT_CATEGORY_BUSINESS_PROOF: \"BUSINESS PROOF\",\n  DOCUMENT_CATEGORY_DOB_PROOF: \"DOB PROOF\",\n  DOCUMENT_CATEGORY_BANK_ACCOUNT_DOCUMENT: \"BANK STATEMENT\",\n  DOCUMENT_CATEGORY_INVESTMENT_PROOF: \"INVESTMENT PROOF\",\n  DOCUMENT_CATEGORY_CATEGORY_PROOF: \"CATEGORY PROOF\",\n  DOCUMENT_CATEGORY_FEE_RECEIPT: \"FEE RECEIPT\",\n  DOCUMENT_CATEGORY_EXCHANGE_DOCUMENTS: \"EXCHANGE DOCUMENTS\",\n  DOCUMENT_CATEGORY_COLLATERAL_PROPERTY: \"COLLATERAL PROPERTY\",\n  DOCUMENT_CATEGORY_LEGAL_DOCUMENT: \"LEGAL DOCUMENT\",\n  DOCUMENT_CATEGORY_RCU_DOCUMENT: \"RCU DOCUMENT\",\n  DOCUMENT_CATEGORY_RCU_ADDITIONAL_DOCUMENTS: \"RCU ADDITIONAL DOCUMENTS\",\n  DOCUMENT_CATEGORY_TECHNICAL_DOCUMENT: \"TECHNICAL DOCUMENT\",\n  DOCUMENT_CATEGORY_PROPERTY_PICTURES: \"PROPERTY PICTURE\",\n  DOCUMENT_CATEGORY_OTHER_DOCUMENTS: \"OTHER DOCUMENTS\",\n  DOCUMENT_CATEGORY_EMPLOYMENT_RETAILS_RECORDING: \"EMPLOYMENT RETAILS RECORDING\",\n  DOCUMENT_CATEGORY_SALARIED_SALARY_PROOF: \"SALARY PROOF\",\n  DOCUMENT_CATEGORY_CREDIT_DOCUMENTS: \"CREDIT DOCUMENTS\",\n  DOCUMENT_CATEGORY_BANK_STATEMENTS_ANALYSIS: \"BANK STATEMENTS ANALYSIS\",\n  DOCUMENT_CATEGORY_REAPPEAL_DOCUMENTS: \"REAPPEAL DOCUMENTS\",\n};\n\nexport const initialDocInfo: IDocumentInfo = {\n  documentUid: \"\",\n  documentName: \"\",\n  documentCode: \"\",\n  documentCategory: \"\",\n  documentSectionUrls: [],\n  isActive: true,\n};\n\nconst initialDocSectionUrl: IUploadedDocumentSection = {\n  uid: \"\",\n  fileName: \"\",\n  url: \"\",\n  thumbUrl: \"\",\n  signedUrl: \"\",\n  contentType: \"\",\n  name: \"\",\n  code: \"\",\n  isActive: true,\n};\n\nconst initialOcr: IOCR = { showPopulateOcr: false, enableOcr: false };\n\nexport const dummySavedDocStructure: ISavedDocumentRecords = {\n  uid: \"\",\n  attributes: {},\n  dob: new Date(),\n  docCategory: \"\",\n  docFor: null,\n  docNo: \"\",\n  docType: {},\n  documentSections: [\n    {\n      uid: \"\",\n      fileName: \"\",\n      fileType: \"\",\n      isActive: false,\n      section: \"\",\n      sectionName: \"\",\n      thumbUrl: \"\",\n      url: \"\",\n    },\n  ],\n  loanSectionKey: \"\",\n  maskedDocNo: \"\",\n  isActive: false,\n};\n\nexport const dummyOcrResponseStructure = {\n  uid: \"\",\n  maskedDocNo: \"\",\n  docNo: \"\",\n  dob: \"\",\n  meta: {},\n  attributes: {},\n  documentSections: [],\n};\n\n// below object literal is used only for Other Documents\nexport const dummySavedDocStructureInList: ISavedDocumentRecords = {\n  listKey: Math.random().toString(36).substring(2),\n  uid: \"\",\n  attributes: {},\n  dob: new Date(),\n  docCategory: \"\",\n  docFor: null,\n  docNo: \"\",\n  docType: {},\n  documentSections: [],\n  loanSectionKey: \"\",\n  maskedDocNo: \"\",\n  isActive: false,\n};\n\nconst DocumentUploader = forwardRef<IDocumentUploaderRef, IDocumentUploaderProps>((props, ref) => {\n  const {\n    mode,\n    queryParamForDocList,\n    docUploadTypeTitle,\n    mandatoryDocUpload,\n    savedDocument,\n    ocrSubstageName,\n    ocrStageName,\n    ocrPayloadData,\n    accessKebab,\n    docUploaderIndex,\n    onRemoveFromList,\n  } = props;\n\n  const documentCardMenuOptions = [\n    {\n      className: `${mode === DOC_UPLOADER_MODE.VIEW ? \"cursor-not-allowed\" : \"\"}`,\n      label: \"Remove\",\n      command: () => {\n        if (onRemoveFromList && docUploaderIndex !== undefined) {\n          onRemoveFromList(uploadedDocumentInfo, docUploaderIndex);\n        }\n      },\n      disabled: mode === DOC_UPLOADER_MODE.VIEW,\n    },\n  ];\n\n  /*--------------------------Hooks------------------------- */\n\n  const [documentDropdownInfo, setDocumentDropdownInfo] = useState<IDocDropdownInfo>({\n    documentTypeList: [], // store the doc type options/list for the document category\n    selectedDocType: \"\", //show the selected doc type in dropdown\n  });\n  //prepare doc sections and render required number of file uploaders\n  const [docSections, setDocSections] = useState<any[]>([]);\n  // store the attribute like name and type of input field required for document type\n  const [docAttributeConfigList, setDocAttributeConfigList] = useState<IDocumentAttribute[]>([]);\n  const [documentMetaDataOptions, setDocumentMetaDataOptions] = useState<IDropDownOption[]>([]);\n  // store all the information about the uploaded document\n  const [uploadedDocumentInfo, setUploadedDocumentInfo] = useState<IDocumentInfo>({\n    ...initialDocInfo,\n    documentCategory: queryParamForDocList,\n  });\n  //to check whether user has changed the saved document received from API response\n  const [isSavedDocTypeChanged, setIsSavedDocTypeChanged] = useState(false);\n  //store the deletedSections which are already saved in DB in an array to send it in the api payload marked with isActive:false when docType is changed\n  const [deletedDocSections, setDeletedDocSections] = useState<IUploadedDocumentSection[]>([]);\n  //store the docSections which are already saved in DB in an array to send it in the api payload by just overriding when docType is not changed\n  const [savedDocSectionsToOveride, setSavedDocSectionsToOveride] = useState<\n    IUploadedDocumentSection[]\n  >([]);\n  const [isMultiSectionMode, setIsMultiSectionMode] = useState(false);\n  const [mediaGalleryInfoListInMultiSectionMode, setMediaGalleryInfoListInMultiSectionMode] =\n    useState<IMediaInfo[]>([]);\n  //store the deletedSections which are already saved in DB in an array to send it in the api payload marked with isActive:false when docType is changed when isMultiSectionMode equals to true\n  const [deletedDocSectionsInMultiFileMode, setDeletedDocSectionsInMultiFileMode] = useState<\n    IUploadedDocumentSection[]\n  >([]);\n\n  const [suggestionsTemplate, setSuggestionsTemplate] = useState<IDocumentUploaderAutocomplete[]>([\n    { name: \"\", uid: \"\", code: \"\" },\n  ]);\n\n  //OCR states\n  const [ocr, setOcr] = useState(initialOcr);\n  const [loaderOcr, setLoaderOcr] = useState(false);\n  const [ocrStatus, setOcrStatus] = useState<IDocUploaderOCRStatus>({\n    success: false,\n    failed: false,\n  });\n  const [ocrData, setOcrData] = useState<IOcrResponse>(dummyOcrResponseStructure);\n\n  //states to handle validations\n  const [, forceUpdate] = useState<undefined | boolean>(undefined);\n  const validator = useRef(\n    new SimpleReactValidator({\n      validators: { ...getStandardValidator() },\n      ...messageReplace(),\n      autoForceUpdate: { forceUpdate: () => forceUpdate((prev) => !prev) },\n    })\n  );\n\n  //states to handle api service errors\n  const [errorMessage, setErrorMessage] = useState(\"\");\n  const [showDialogAPIError, setShowDialogAPIError] = useState(false);\n\n  //refs\n  const fileUploaderRef = useRef<IFileUploadCustomRef[]>([]);\n\n  useEffect(() => {\n    init();\n  }, []);\n\n  // to display service error pop up\n  useEffect(() => {\n    if (errorMessage) {\n      setShowDialogAPIError(true);\n    }\n  }, [errorMessage]);\n\n  //effect function to structure and render files from savedDocument received via props\n  useEffect(() => {\n    if (\n      savedDocument?.uid &&\n      documentDropdownInfo.documentTypeList.length &&\n      !documentDropdownInfo.selectedDocType\n    ) {\n      setDocumentDropdownInfo((prev: IDocDropdownInfo) => ({\n        ...prev,\n        selectedDocType: savedDocument.docType?.code,\n      }));\n\n      const selectedDocumentType = documentDropdownInfo.documentTypeList.find(\n        (document: IDocument) => document.value === savedDocument.docType?.code\n      );\n      selectedDocumentType ? prepareDocumentSections(selectedDocumentType) : null;\n    }\n\n    if (\n      savedDocument?.documentSections?.length &&\n      docSections.length &&\n      !uploadedDocumentInfo.documentSectionUrls.length &&\n      !isSavedDocTypeChanged\n    ) {\n      prepareDocInfoFromSavedAndRender();\n    }\n  }, [savedDocument, documentDropdownInfo, docSections]);\n\n  //effect function for OCR\n  useEffect(() => {\n    if (ocrStatus) {\n      ocrStatus.failed || ocrStatus.success ? setLoaderOcr(false) : null;\n    }\n\n    if (ocrData.uid) {\n      const documentSectionUrlsCopy: IUploadedDocumentSection[] = [];\n      const documentSectionUrlsMap = new Map();\n      for (const docSection of uploadedDocumentInfo.documentSectionUrls) {\n        documentSectionUrlsMap.set(docSection.code, docSection);\n      }\n      ocrData.documentSections.forEach((section, idx) => {\n        const docSection = documentSectionUrlsMap.get(section.sectionName);\n        documentSectionUrlsCopy.push({\n          ...docSection,\n          uid: section.uid,\n        });\n      });\n\n      setUploadedDocumentInfo((prev: IDocumentInfo) => ({\n        ...prev,\n        documentSectionUrls: [...documentSectionUrlsCopy],\n      }));\n\n      //iterate attribute config list\n      const currentDocAttributes = docAttributeConfigList.find(\n        (docAttribute) => docAttribute.docCode === documentDropdownInfo.selectedDocType\n      );\n\n      if (currentDocAttributes) {\n        for (const docAttribute of currentDocAttributes.attributes) {\n          if (docAttribute.isPrimaryAttribute) {\n            setUploadedDocumentInfo((prev: IDocumentInfo) => ({\n              ...prev,\n              [`${docAttribute.name}`]: ocrData.docNo,\n            }));\n          }\n        }\n        return;\n      }\n    }\n\n    if (docSections.length) {\n      // check if selected doc type supports ocr or not\n      const isOcrAvailableInDocType = docSections.some((section) => section.isOcrActive === true);\n\n      //if it supports\n      if (isOcrAvailableInDocType) {\n        setOcr((prev) => {\n          return {\n            ...prev,\n            showPopulateOcr: true,\n          };\n        });\n      }\n      //if it doesn't\n      else {\n        setOcr((prev) => {\n          return {\n            ...prev,\n            showPopulateOcr: false,\n          };\n        });\n      }\n    }\n  }, [docSections.length, ocrStatus]);\n\n  //effect function for media gallery information list\n  useEffect(() => {\n    if (isMultiSectionMode) {\n      prepareMediaGalleryInfoList();\n    }\n  }, [uploadedDocumentInfo.documentSectionUrls]);\n\n  useImperativeHandle(ref, () => ({\n    getUploadedData: prepareUploadedData,\n    resetValidator: resetValidator,\n    resetDocUpload: resetAllStates,\n  }));\n\n  //get the saved sections and prepare uploadedDocumentInfo documentSectionUrls\n  const prepareDocInfoFromSavedAndRender = useCallback(() => {\n    //structure the saved document sections into document url\n    const structDocUrlFromSaved: IUploadedDocumentSection[] = [];\n\n    if (savedDocument?.documentSections) {\n      for (const savedDocSection of savedDocument.documentSections) {\n        const selectedDoc = docSections.find((docSection) => {\n          docSection.code === savedDocSection.section;\n        });\n\n        //if saved section allows ocr activate ocr button\n        selectedDoc?.isOcrActive\n          ? setOcr((prev) => {\n              return { ...prev, enableOcr: true };\n            })\n          : null;\n\n        structDocUrlFromSaved.push({\n          [`${savedDocSection.sectionName}`]: savedDocSection.url,\n          uid: savedDocSection.uid,\n          fileName: savedDocSection.fileName,\n          url: savedDocSection.url,\n          thumbUrl: savedDocSection.thumbUrl,\n          contentType: savedDocSection.fileType,\n          code: savedDocSection.section,\n          name: savedDocSection.sectionName,\n          meta: savedDocSection?.meta ? JSON.parse(savedDocSection?.meta) : \"\",\n          isActive: savedDocSection.isActive,\n          isOcrActive: selectedDoc?.isOcrActive ?? false,\n        });\n      }\n    }\n\n    setUploadedDocumentInfo((prev: IDocumentInfo) => ({\n      ...prev,\n      uid: savedDocument?.uid,\n      documentSectionUrls: [...structDocUrlFromSaved],\n      ...savedDocument?.attributes,\n    }));\n  }, [savedDocument, isMultiSectionMode]);\n\n  /*----------------------------Event Handlers -> onChange, onBlur, onFocus ----------------------- */\n\n  const resetIfSavedDocTypeChange = () => {\n    const updateSectionsWhenDeleted = () => {\n      if (savedDocument) {\n        const deletedSections: any[] = savedDocument?.documentSections?.map(\n          (docSection, index) => ({\n            uid: docSection.uid,\n            fileName: docSection.fileName,\n            url: docSection.url,\n            thumbUrl: docSection.thumbUrl,\n            contentType: docSection.fileType,\n            code: docSection.section,\n            name: docSection.sectionName,\n            isActive: false, // update isActive value to false for every section when docType changes\n          })\n        );\n        return deletedSections;\n      } else {\n        return [];\n      }\n    };\n    if (savedDocument) {\n      if (!deletedDocSections.length && !isMultiSectionMode) {\n        setDeletedDocSections((prev) => [...prev, ...updateSectionsWhenDeleted()]);\n      } else if (!deletedDocSectionsInMultiFileMode.length && isMultiSectionMode) {\n        setDeletedDocSectionsInMultiFileMode((prev) => [...prev, ...updateSectionsWhenDeleted()]);\n      }\n      setIsSavedDocTypeChanged(true);\n    }\n  };\n\n  const handleDocTypeChange = (e: DropdownChangeParams) => {\n    setDocumentDropdownInfo((prev: IDocDropdownInfo) => ({\n      ...prev,\n      selectedDocType: e.value,\n    }));\n\n    const selectedDocumentType = documentDropdownInfo.documentTypeList.find(\n      (document: IDocument) => document.value === e.value\n    );\n    selectedDocumentType ? prepareDocumentSections(selectedDocumentType) : null;\n\n    //if the saved document type from API response is changed\n    savedDocument?.uid ? resetIfSavedDocTypeChange() : null;\n\n    resetValidator();\n  };\n\n  const handleInputChange = (e: BaseSyntheticEvent) => {\n    setUploadedDocumentInfo((prev: IDocumentInfo) => ({\n      ...prev,\n      [e.target.name]: e.target.value.toUpperCase(),\n    }));\n  };\n\n  const handleDateChange = (e: CalendarChangeParams) => {\n    const { value } = e.target;\n    setUploadedDocumentInfo((prev: IDocumentInfo) => ({\n      ...prev,\n      [e.target.name]: value,\n    }));\n  };\n\n  const handleAutoCompleteChange = (event: any) => {\n    const { name, value } = event.target;\n    let fieldValue = \"\";\n    let fieldCode = \"\";\n    if (typeof value === \"object\") {\n      if (value.name) fieldValue = value.name;\n      if (value.code) {\n        fieldCode = value?.code?.replace(`${value?.staticMasterType?.code}_`, \"\");\n      }\n      setUploadedDocumentInfo((prev: IDocumentInfo) => ({\n        ...prev,\n        [name]: { name: fieldValue, uid: value.uid, code: fieldCode },\n      }));\n    } else {\n      setUploadedDocumentInfo((prev: IDocumentInfo) => ({\n        ...prev,\n        [name]: { name: value, uid: \"\", code: \"\" },\n      }));\n    }\n  };\n\n  /*----------------------------Event Handlers -> onClick  ----------------------- */\n\n  const onPopulateOCR = async () => {\n    if (validateAllUploaders()) return;\n\n    setLoaderOcr(true);\n\n    if (ocrStageName) {\n      const URL_PATH = `${ocrStageName}${ocrSubstageName ? `/${ocrSubstageName}` : \"\"}`;\n      const payload = enrichPopulateOcrInDocUploader({\n        ...uploadedDocumentInfo,\n        uid: savedDocument?.uid\n          ? savedDocument?.uid\n          : uploadedDocumentInfo.uid\n          ? uploadedDocumentInfo.uid\n          : null,\n      });\n\n      try {\n        const res = await DocumentOcrService.populateUsingOcr(payload, URL_PATH);\n        if (validatePostAPIResponse(res)) {\n          const { data: ocrData } = res;\n\n          const getSectionsInfo = (docSections: any[]) => {\n            return docSections.map((docSection: any) => ({\n              sectionName: docSection.section,\n              uid: docSection.uid,\n            }));\n          };\n\n          const preparedOcrData: IOcrResponse = {\n            uid: ocrData.uid,\n            docNo: ocrData.docNo,\n            dob: ocrData.dob,\n            meta: JSON.parse(ocrData.meta) ?? {},\n            maskedDocNo: ocrData.maskedDocNo,\n            attributes: JSON.parse(ocrData.attributes) ?? {},\n            documentSections: getSectionsInfo(ocrData.documentSections),\n          };\n\n          setOcrData({ ...preparedOcrData });\n          setOcrStatus((prev) => {\n            return { ...prev, success: true, failed: false };\n          });\n        }\n      } catch (error) {\n        setOcrStatus((prev) => {\n          return { ...prev, success: false, failed: true };\n        });\n        setErrorMessage(parseStandardAPIErrorMessage(error));\n      }\n    }\n  };\n\n  const onValidateDocumentType = () => {\n    //validate logic for the selected document\n  };\n\n  /*-----------------------------Validators-------------------------------------- */\n\n  const validate = (e: React.BaseSyntheticEvent) => {\n    validator?.current?.showMessageFor(e?.target?.name);\n  };\n\n  const validateForm = () => {\n    let isValid = false;\n    isValid = validator?.current?.allValid() ?? false;\n    if (isValid) {\n      return isValid;\n    } else {\n      forceUpdate((prev) => !prev);\n      validator?.current?.showMessages();\n      forceUpdate((prev) => !prev);\n      return false;\n    }\n  };\n\n  const resetValidator = () => {\n    validator.current = new SimpleReactValidator({\n      validators: { ...getStandardValidator() },\n      ...messageReplace(),\n      autoForceUpdate: { forceUpdate: () => forceUpdate((prev) => !prev) },\n    });\n\n    let currentFileUploaderIdx = 0;\n    for (\n      currentFileUploaderIdx;\n      currentFileUploaderIdx < fileUploaderRef?.current?.length;\n      currentFileUploaderIdx++\n    ) {\n      if (fileUploaderRef?.current?.[currentFileUploaderIdx]) {\n        fileUploaderRef?.current?.[currentFileUploaderIdx].resetErrorStates();\n      }\n    }\n  };\n\n  const validateAllUploaders = (): boolean => {\n    let currentFileUploaderIdx = 0;\n    const uploadStatusListInUploader: boolean[] = []; //store boolean value for each uploader by checking preview is available or not if yes user has uploaded if no user hasn't\n    const metaSelectionListInUploader: boolean[] = []; //store boolean value for each uploader in multi section mode checking if each uploader has its meta selected\n    for (\n      currentFileUploaderIdx;\n      currentFileUploaderIdx < fileUploaderRef?.current?.length;\n      currentFileUploaderIdx++\n    ) {\n      if (fileUploaderRef?.current?.[currentFileUploaderIdx]) {\n        uploadStatusListInUploader.push(\n          fileUploaderRef?.current?.[currentFileUploaderIdx].isUrlAvailable()\n        );\n        if (isMultiSectionMode) {\n          metaSelectionListInUploader.push(\n            fileUploaderRef?.current?.[currentFileUploaderIdx].isSectionNameAvailable()\n          );\n        }\n      }\n    }\n\n    if (!isMultiSectionMode) {\n      return uploadStatusListInUploader.some((val) => !val);\n    } else {\n      return (\n        uploadStatusListInUploader.some((val) => !val) ||\n        metaSelectionListInUploader.some((val) => !val)\n      );\n    }\n  };\n\n  /*-------------------------------Helper Functions----------------- */\n\n  const init = async () => {\n    prepareDocTypeList();\n  };\n\n  const prepareDocTypeList = async () => {\n    getDocTypeList();\n  };\n\n  const prepareDocumentSections = async (selectedDocumentType: IDocument) => {\n    if (selectedDocumentType && selectedDocumentType.uid) {\n      const res = await getSectionList(selectedDocumentType.uid);\n\n      const sections: any[] = [];\n      const metaDataOptions: IDropDownOption[] = [];\n\n      res?.documentSections?.forEach((documentSection: any) => {\n        if (documentSection.isActive) {\n          if (documentSection.section?.code === DOCUMENT_SECTION.DOCUMENT_SECTIONS_FRONT_PAGE) {\n            sections.unshift({\n              ...documentSection.section,\n              isOcrActive: documentSection.isOcrActive,\n              documentSectionUid: documentSection.uid,\n            });\n          } else {\n            sections.push({\n              ...documentSection.section,\n              isOcrActive: documentSection.isOcrActive,\n              documentSectionUid: documentSection.uid,\n            });\n          }\n\n          metaDataOptions.push({\n            label: documentSection.section?.name,\n            value: documentSection.section?.code,\n          });\n        }\n      });\n\n      if (!selectedDocumentType.isMultiFileAllowedPerSection) {\n        setUploadedDocumentInfo({\n          uid: null, // uid of an unsaved document\n          documentCategory: queryParamForDocList,\n          documentUid: selectedDocumentType.uid,\n          documentName: selectedDocumentType.label,\n          documentCode: selectedDocumentType.value,\n          documentSectionUrls: [],\n          isActive: selectedDocumentType.isActive,\n        });\n        setIsMultiSectionMode(false);\n      } else {\n        //allow n number of uploads\n        setUploadedDocumentInfo({\n          uid: null, // uid of an unsaved document\n          documentCategory: queryParamForDocList,\n          documentUid: selectedDocumentType.uid,\n          documentName: selectedDocumentType.label,\n          documentCode: selectedDocumentType.value,\n          documentSectionUrls: [],\n          isActive: selectedDocumentType.isActive,\n        });\n        setIsMultiSectionMode(true);\n      }\n      setDocSections([...sections]);\n      setDocumentMetaDataOptions([...metaDataOptions]);\n      setOcrData(dummyOcrResponseStructure);\n    }\n  };\n\n  const getDocTypeList = async () => {\n    try {\n      const res = await DocumentCategoryService.getDocumentCategory(\n        0,\n        50,\n        `${queryParamForDocList}`\n      );\n\n      if (validateGetAPIResponse(res) && !!res.data?.totalRecords) {\n        const { results: documentTypeLists } = res.data;\n\n        const preparedDocumentList: IDocument[] = [];\n        let preparedDocAttrConfigList: IDocumentAttribute[] = [];\n\n        const findPrimaryKeyAttributeName = (attributes: any) => {\n          for (const attribute of attributes) {\n            if (attribute.isPrimaryAttribute) return attribute.name;\n          }\n          return \"\";\n        };\n\n        documentTypeLists.forEach((record: any) => {\n          preparedDocumentList.push({\n            uid: record.documentType?.uid ?? \"\",\n            label: record.documentType?.name ?? \"\",\n            value: record.documentType?.code ?? \"\",\n            isActive: record.documentType?.isActive ?? false,\n            hasDocumentNumber: record.documentType?.hasDocumentNumber ?? undefined,\n            isMultiFileAllowedPerSection:\n              record.documentType?.isMultiFileAllowedPerSection ?? undefined,\n          });\n\n          preparedDocAttrConfigList.push({\n            docCode: record.documentType?.code,\n            attributes: record.documentType?.attributeConfig\n              ? JSON.parse(record.documentType?.attributeConfig)\n              : [],\n            primaryKey: \"\",\n          });\n        });\n\n        preparedDocAttrConfigList = preparedDocAttrConfigList.map((docAttributes) => ({\n          ...docAttributes,\n          primaryKey: findPrimaryKeyAttributeName(docAttributes.attributes),\n        }));\n\n        preparedDocumentList.length\n          ? setDocumentDropdownInfo({\n              documentTypeList: [...preparedDocumentList],\n              selectedDocType: \"\",\n            })\n          : setDocumentDropdownInfo({\n              documentTypeList: [],\n              selectedDocType: \"\",\n            });\n\n        preparedDocAttrConfigList.length\n          ? setDocAttributeConfigList([...preparedDocAttrConfigList])\n          : setDocAttributeConfigList([]);\n      }\n    } catch (error) {\n      setErrorMessage(parseStandardAPIErrorMessage(error));\n    }\n  };\n\n  const getSectionList = async (uid: string) => {\n    try {\n      const res = await DocumentService.getDocument(uid);\n      if (validateGetAPIResponse(res)) {\n        return res.data;\n      }\n    } catch (error) {\n      setErrorMessage(parseStandardAPIErrorMessage(error));\n    }\n  };\n\n  const getUploadedFileInfo = (uploadedFile: IUploadedFile, section: any) => {\n    setUploadedDocumentInfo((prev: IDocumentInfo) => ({\n      ...prev,\n      documentSectionUrls: [\n        ...prev.documentSectionUrls,\n        {\n          [`${section.name}`]: uploadedFile.url,\n          ...uploadedFile,\n          code: section.code,\n          name: section.name,\n          isActive: true,\n          isOcrActive: section.isOcrActive,\n          uid: null,\n        },\n      ],\n    }));\n\n    if (section.isOcrActive) {\n      setOcr((prev) => {\n        return { ...prev, enableOcr: true };\n      });\n    }\n  };\n\n  const getSavedFileSignedUrl = (signedUrl: string, section: any) => {\n    const docSectionUrls = uploadedDocumentInfo.documentSectionUrls;\n    docSectionUrls.forEach((docSection, idx) => {\n      if (docSection.code === section.code) {\n        docSectionUrls[idx] = {\n          ...docSectionUrls[idx],\n          signedUrl: signedUrl,\n        };\n      }\n    });\n\n    setUploadedDocumentInfo((prev: IDocumentInfo) => ({\n      ...prev,\n      documentSectionUrls: [...docSectionUrls],\n    }));\n  };\n\n  const prepareUploadedData = () => {\n    let documentUploaderData: IDocumentInfo = { ...uploadedDocumentInfo };\n\n    const getPrimaryAttributeKeyName = (documentCode: string) => {\n      for (const docAttribute of docAttributeConfigList) {\n        if (docAttribute.docCode === documentCode) {\n          return docAttribute.primaryKey;\n        }\n      }\n    };\n\n    const getDocSectionsUrlsByOveriding = (\n      docSectionUrls: IUploadedDocumentSection[]\n    ): IUploadedDocumentSection[] => {\n      const overiddenSectionUrls = docSectionUrls.map((docSection: IUploadedDocumentSection) => {\n        const getSavedPreviousSection = savedDocSectionsToOveride.find(\n          (docSectionToOveride) => docSectionToOveride.code === docSection.code\n        );\n        if (getSavedPreviousSection) {\n          const savedDocSectionuid = getSavedPreviousSection.uid;\n          return {\n            ...docSection,\n            uid: savedDocSectionuid,\n          };\n        } else {\n          return { ...docSection };\n        }\n      });\n      return overiddenSectionUrls;\n    };\n\n    //filter the sections in uploadedDocumentInfo that have url\n    const filterUplodedSectionsByUrl = (documentUploaderData: IDocumentInfo) => {\n      const uploadedDocumentProofs: IUploadedDocumentSection[] =\n        documentUploaderData.documentSectionUrls.filter(\n          (document: IUploadedDocumentSection) => document.url\n        );\n      documentUploaderData.documentSectionUrls = [...uploadedDocumentProofs];\n      return documentUploaderData;\n    };\n\n    //get uploadedDocumentInfo with all the deleted sections of document that supports n section uploads\n    const getDocInfoWithAllDeletedSecInMultiSectionMode = () => {\n      const docUploaderData = {\n        ...uploadedDocumentInfo,\n        documentSectionUrls: [\n          ...uploadedDocumentInfo.documentSectionUrls,\n          ...deletedDocSectionsInMultiFileMode,\n        ],\n        uid: savedDocument?.uid ? savedDocument?.uid : null,\n        primaryKeyAttributeName: getPrimaryAttributeKeyName(uploadedDocumentInfo.documentCode),\n      };\n      return docUploaderData;\n    };\n\n    const allUploaderValidation = validateAllUploaders();\n\n    if (!validateForm() || allUploaderValidation) {\n      return;\n    }\n\n    //uploader data for PUT\n    if (savedDocument?.uid && isSavedDocTypeChanged) {\n      if (!isMultiSectionMode) {\n        documentUploaderData = {\n          ...uploadedDocumentInfo,\n          documentSectionUrls: [...uploadedDocumentInfo.documentSectionUrls, ...deletedDocSections],\n          uid: savedDocument.uid ? savedDocument.uid : null,\n          primaryKeyAttributeName: getPrimaryAttributeKeyName(uploadedDocumentInfo.documentCode),\n        };\n        documentUploaderData = { ...filterUplodedSectionsByUrl(documentUploaderData) };\n        setDeletedDocSections([]);\n        return documentUploaderData;\n      } else {\n        documentUploaderData = { ...getDocInfoWithAllDeletedSecInMultiSectionMode() };\n        documentUploaderData = { ...filterUplodedSectionsByUrl(documentUploaderData) };\n        setDeletedDocSectionsInMultiFileMode([]);\n        return documentUploaderData;\n      }\n    }\n\n    //uploader data for PUT\n    if (savedDocument?.uid && !isSavedDocTypeChanged) {\n      if (!isMultiSectionMode) {\n        documentUploaderData = {\n          ...uploadedDocumentInfo,\n          documentSectionUrls: getDocSectionsUrlsByOveriding(\n            uploadedDocumentInfo.documentSectionUrls\n          ),\n          uid: savedDocument?.uid ? savedDocument?.uid : null,\n          primaryKeyAttributeName: getPrimaryAttributeKeyName(uploadedDocumentInfo.documentCode),\n        };\n        documentUploaderData = { ...filterUplodedSectionsByUrl(documentUploaderData) };\n        setSavedDocSectionsToOveride([]);\n        return documentUploaderData;\n      } else {\n        documentUploaderData = { ...getDocInfoWithAllDeletedSecInMultiSectionMode() };\n        documentUploaderData = { ...filterUplodedSectionsByUrl(documentUploaderData) };\n        setDeletedDocSectionsInMultiFileMode([]);\n        return documentUploaderData;\n      }\n    }\n\n    //uploader data for POST\n    documentUploaderData = {\n      ...filterUplodedSectionsByUrl(documentUploaderData),\n      primaryKeyAttributeName: getPrimaryAttributeKeyName(uploadedDocumentInfo.documentCode),\n    };\n\n    return documentUploaderData;\n  };\n\n  // delete a specific section url from the state uploadedDocumentInfo if deleted from uploader when isMultiSectionMode is false\n  const onDeleteFromUploader = (sectionName: string) => {\n    let isOcrAvailable = false; //check if the section to be deleted allows ocr or not\n    const deletedSection: IUploadedDocumentSection[] = [];\n\n    const updatedDocumentUrl = uploadedDocumentInfo.documentSectionUrls.filter((doc) => {\n      if (doc.name === sectionName) {\n        isOcrAvailable = doc.isOcrActive;\n      }\n\n      if (doc.name === sectionName && doc.uid && !isSavedDocTypeChanged) {\n        deletedSection[0] = {\n          ...doc,\n        };\n        setSavedDocSectionsToOveride((prev) => [...prev, ...deletedSection]);\n      }\n\n      return doc.name !== sectionName;\n    });\n\n    //function to check if there is any uploaded section which has ocr active in `const updatedDocumentUrl`. if yes then keep ocr button enabled else disable it\n    const isOcrSectionPresent = () => {\n      return updatedDocumentUrl.some((doc) => {\n        return doc.isOcrActive;\n      });\n    };\n\n    // if section allows ocr then disable populate with ocr text button when the section is deleted\n    if (isOcrAvailable && !isOcrSectionPresent()) {\n      setOcr((prev) => {\n        return {\n          ...prev,\n          enableOcr: false,\n        };\n      });\n    }\n\n    setUploadedDocumentInfo({\n      ...uploadedDocumentInfo,\n      documentSectionUrls: [...updatedDocumentUrl],\n    });\n  };\n\n  const enrichPopulateOcrInDocUploader = (uploadedDocInfo: IDocumentInfo) => {\n    const prepareDocSections = (documentSections: IUploadedDocumentSection[]) => {\n      const sections = documentSections.map((docSection: any) => ({\n        section: docSection.code,\n        fileName: docSection.fileName,\n        fileType: docSection.contentType,\n        thumbUrl: docSection.thumbUrl,\n        url: docSection.url,\n        meta: \"\",\n      }));\n      return sections;\n    };\n\n    const getSectionSignedUrl = (sectionCode: string) => {\n      const section = uploadedDocInfo.documentSectionUrls.find((docSection) => {\n        return docSection.isOcrActive && docSection.code === sectionCode && docSection.isActive;\n      });\n      return section?.signedUrl;\n    };\n    return {\n      uid: uploadedDocInfo.uid, //if a document is already saved and then ocr is done then pass its uid\n      loan: {\n        uid: ocrPayloadData?.loanUid ? ocrPayloadData?.loanUid : \"\",\n      },\n      applicant: {\n        uid: ocrPayloadData?.applicant?.uid ? ocrPayloadData?.applicant?.uid : \"\",\n      },\n      docType: {\n        uid: uploadedDocInfo.documentUid,\n      },\n      docNo: \"\",\n      documentSections: prepareDocSections(uploadedDocInfo.documentSectionUrls),\n      backSignedUrl: getSectionSignedUrl(DOCUMENT_SECTION.DOCUMENT_SECTIONS_BACK_PAGE) ?? \"\",\n      frontSignedUrl: getSectionSignedUrl(DOCUMENT_SECTION.DOCUMENT_SECTIONS_FRONT_PAGE) ?? \"\",\n    };\n  };\n\n  /*-----------------------------------------MULTI FILE UPLOAD LOGIC------------------------------------- */\n  // if multifile upload mode is active\n  const getMultiUploadedFileInfo = (uploadedFile: IUploadedFile, index: number) => {\n    const docSectionUrls = [...uploadedDocumentInfo.documentSectionUrls];\n\n    docSectionUrls.push({\n      ...initialDocSectionUrl,\n      ...uploadedFile,\n      uid: null,\n      keyIndex: Math.random().toString(36).substring(2),\n    });\n\n    setUploadedDocumentInfo({\n      ...uploadedDocumentInfo,\n      documentSectionUrls: [...docSectionUrls],\n    });\n  };\n\n  const getSelectedMeta = (metaData: any, index: number) => {\n    const docSectionUrls = [...uploadedDocumentInfo.documentSectionUrls];\n    docSectionUrls[index] = {\n      ...docSectionUrls[index],\n      [`${metaData.section.label}`]: docSectionUrls[index].url,\n      code: metaData.section.value,\n      name: metaData.section.label,\n    };\n\n    setUploadedDocumentInfo({\n      ...uploadedDocumentInfo,\n      documentSectionUrls: [...docSectionUrls],\n    });\n  };\n\n  const isMediaValidationRequired = (): boolean => {\n    if (\n      queryParamForDocList === DOCUMENT_CATEGORY.DOCUMENT_CATEGORY_EMPLOYMENT_RETAILS_RECORDING &&\n      (uploadedDocumentInfo.documentCode === \"VIDEO\" ||\n        uploadedDocumentInfo.documentCode === \"AUDIO\")\n    ) {\n      return true;\n    }\n\n    return false;\n  };\n\n  //delete the uploader when isMultiSectionMode is true\n  const onDeleteInMultiFileMode = (sectionName: string, index: number) => {\n    //clear the content as well as the remove the uploader from the queue/list\n    const docSectionUrls = [...uploadedDocumentInfo.documentSectionUrls];\n\n    //if it is a already saved section in DB then push it into deletedDocSectionsInMultiFileMode array\n    if (docSectionUrls[index]?.uid) {\n      setDeletedDocSectionsInMultiFileMode((prev) => [\n        ...prev,\n        { ...docSectionUrls[index], isActive: false },\n      ]);\n    }\n\n    docSectionUrls.splice(index, 1);\n\n    setUploadedDocumentInfo({\n      ...uploadedDocumentInfo,\n      documentSectionUrls: [...docSectionUrls],\n    });\n  };\n\n  const resetAllStates = () => {\n    setDocumentDropdownInfo((prev: IDocDropdownInfo) => ({ ...prev, selectedDocType: \"\" }));\n    setDocSections([]);\n    setDocumentMetaDataOptions([]);\n    setUploadedDocumentInfo({\n      ...initialDocInfo,\n      documentCategory: queryParamForDocList,\n    });\n    setIsSavedDocTypeChanged(false);\n    setDeletedDocSections([]);\n    setSavedDocSectionsToOveride([]);\n    setIsMultiSectionMode(false);\n    setDeletedDocSectionsInMultiFileMode([]);\n    setOcr(initialOcr);\n    setLoaderOcr(false);\n    setOcrStatus({\n      success: false,\n      failed: false,\n    });\n    setOcrData(dummyOcrResponseStructure);\n  };\n\n  /*---------------------------------------------------------------------------------------------------*/\n\n  const sortSectionsByName = (sections: any[]) => {\n    const sortedSections: IUploadedDocumentSection[] = [];\n    const sectionCodeMap = new Map();\n\n    sections.forEach((section) => {\n      sectionCodeMap.set(section.code, section);\n    });\n\n    for (let idx = 0; idx < docSections.length; idx++) {\n      sortedSections.push(sectionCodeMap.get(docSections[idx].code));\n    }\n    return sortedSections;\n  };\n\n  const prepareMediaGalleryInfoList = () => {\n    const preparedInfoInList: IMediaInfo[] = uploadedDocumentInfo.documentSectionUrls.map(\n      (docSection) => {\n        return {\n          uid: docSection.uid ?? Math.random().toString(36).substring(2),\n          placeOfUpload: \"\",\n          name: \"\",\n          fileName: docSection.fileName,\n          fileType: docSection.contentType,\n          download: \"\",\n          category: DOCUMENT_UPLOAD_CATEGORY_LABEL[`${queryParamForDocList}`] ?? \"\",\n          type: uploadedDocumentInfo.documentName,\n          sectionName: docSection.name ?? \"\",\n          url: docSection.url,\n        };\n      }\n    );\n\n    setMediaGalleryInfoListInMultiSectionMode([...preparedInfoInList]);\n  };\n\n  const searchAutocomplete = async (event: any) => {\n    let suggestionsTemplate = [];\n    await StaticMasterDataService.getAll(\n      0,\n      10,\n      `staticMasterType.code=ELECTRICITY_SERVICE_PROVIDER&isActive=true&name:lk=${event.query}`\n    ).then((res) => {\n      if (res.status === 200) {\n        suggestionsTemplate = [...res.data.results];\n      }\n    });\n    if (suggestionsTemplate.length === 0) {\n      suggestionsTemplate.push({ name: \"\", code: \"\", uid: \"\" });\n    }\n    setSuggestionsTemplate(suggestionsTemplate);\n  };\n\n  /*--------------------------Sectional Renders------------------------- */\n\n  // to show a dummy uploader when nothing is selected from dropdown\n  const renderDummyUploader = (): ReactNode => {\n    return (\n      <div className=\"pointer-events-none h-32.5\">\n        <FileUploadCustom disabled />\n      </div>\n    );\n  };\n\n  //loader icon\n  const renderLoaderIcon = (): ReactNode => {\n    return (\n      <span>\n        <img className=\"w-3 h-3 animate-spin\" src={LoaderIcon} alt=\"loader\" />\n      </span>\n    );\n  };\n\n  const renderSectionUploaders = (): ReactNode => {\n    const category = {\n      label: `${\n        DOCUMENT_UPLOAD_CATEGORY_LABEL[`${queryParamForDocList}`]\n          ? DOCUMENT_UPLOAD_CATEGORY_LABEL[`${queryParamForDocList}`]\n          : \"\"\n      }`,\n      value: queryParamForDocList,\n    };\n    const defaultOptions = { label: \"\", value: \"\" };\n\n    const prepareMediaGalleryInfo = (idx: number) => {\n      if (uploadedDocumentInfo.documentSectionUrls.length > 0) {\n        let sections = [...uploadedDocumentInfo.documentSectionUrls];\n        sections = sortSectionsByName(sections);\n\n        const collectedMediaInfo: any = {\n          ...sections[idx],\n          sectionName: sections[idx]?.name,\n          category: category.label,\n          type: uploadedDocumentInfo.documentName,\n        };\n\n        const preparedInfo: IMediaInfo = {\n          uid: \"\",\n          placeOfUpload: \"\",\n          name: \"\",\n          fileName: collectedMediaInfo?.fileName,\n          fileType: collectedMediaInfo?.contentType,\n          download: \"\",\n          category: collectedMediaInfo?.category,\n          type: collectedMediaInfo?.type,\n          sectionName: collectedMediaInfo?.name,\n          url: collectedMediaInfo?.url,\n        };\n        return preparedInfo;\n      }\n    };\n\n    return (\n      <div className={`flex`}>\n        <div className=\"h-38 flex gap-x-6 overflow-x-auto custom-kyc-doc-scroll\">\n          {docSections.map((section, index) => {\n            return (\n              <FileUploadCustom\n                key={`file-uploader-${uploadedDocumentInfo.documentCode}-${section.documentSectionUid}`}\n                ref={(refValue) => {\n                  fileUploaderRef.current[index] = refValue as IFileUploadCustomRef;\n                }}\n                mode={\n                  savedDocument?.uid && !isSavedDocTypeChanged ? FILE_UPLOADER_MODE.mode : undefined\n                }\n                uploaderIndex={index}\n                getUrl={(uploadedFile: IUploadedFile) => {\n                  getUploadedFileInfo(uploadedFile, section);\n                }}\n                savedFileInfoFromApi={uploadedDocumentInfo.documentSectionUrls.find(\n                  (docSection) => docSection.code === section.code\n                )}\n                getSavedFileSignedUrl={(signedUrl) => {\n                  getSavedFileSignedUrl(signedUrl, section);\n                }}\n                docInfoForMediaGallery={prepareMediaGalleryInfo(index)}\n                footerTitle={section.name}\n                clearCardUploadSectionData={onDeleteFromUploader}\n                metaCategoryDropdownOptions={[category ?? defaultOptions]}\n                metaTypeDropdownOptions={[\n                  {\n                    uid: uploadedDocumentInfo.documentUid,\n                    label: uploadedDocumentInfo.documentName,\n                    value: uploadedDocumentInfo.documentCode,\n                  },\n                ]}\n                metaSectionDropdownOptions={documentMetaDataOptions ?? [defaultOptions]}\n                disableMetaCategory\n                disableMetaType\n                disableMetaSection\n                disableKebab={mode === DOC_UPLOADER_MODE.VIEW}\n                disabled={mode === DOC_UPLOADER_MODE.VIEW}\n              />\n            );\n          })}\n        </div>\n      </div>\n    );\n  };\n\n  const renderMultiSectionUploaders = (): ReactNode => {\n    const category = {\n      label: `${\n        DOCUMENT_UPLOAD_CATEGORY_LABEL[`${queryParamForDocList}`]\n          ? DOCUMENT_UPLOAD_CATEGORY_LABEL[`${queryParamForDocList}`]\n          : \"\"\n      }`,\n      value: queryParamForDocList,\n    };\n    const defaultOptions = { label: \"\", value: \"\" };\n    return (\n      <div className={`flex`}>\n        <div className=\"h-38 flex gap-x-6 overflow-x-auto custom-kyc-doc-scroll\">\n          {uploadedDocumentInfo.documentSectionUrls.map((section, index) => {\n            return (\n              <FileUploadCustom\n                key={`file-uploader-${section.uid ? section.uid : section.keyIndex}`}\n                ref={(refValue) => {\n                  fileUploaderRef.current[index] = refValue as IFileUploadCustomRef;\n                }}\n                mode={section.url ? FILE_UPLOADER_MODE.mode : undefined}\n                uploaderIndex={index}\n                savedFileInfoFromApi={uploadedDocumentInfo.documentSectionUrls[index]}\n                docInfoListForMediaGallery={mediaGalleryInfoListInMultiSectionMode}\n                footerTitle={section.name}\n                clearCardUploadSectionData={(sectionName) => {\n                  onDeleteInMultiFileMode(sectionName, index);\n                }}\n                metaCategoryDropdownOptions={[category ?? defaultOptions]}\n                metaTypeDropdownOptions={[\n                  {\n                    uid: uploadedDocumentInfo.documentUid,\n                    label: uploadedDocumentInfo.documentName,\n                    value: uploadedDocumentInfo.documentCode,\n                  },\n                ]}\n                metaSectionDropdownOptions={documentMetaDataOptions ?? [defaultOptions]}\n                getSelectedMetaOptions={getSelectedMeta}\n                disableMetaCategory\n                disableMetaType\n                disableKebab={mode === DOC_UPLOADER_MODE.VIEW}\n                disabled={mode === DOC_UPLOADER_MODE.VIEW}\n              />\n            );\n          })}\n\n          <FileUploadCustom\n            isDummy\n            getUrl={(uploadedFile: IUploadedFile) => {\n              getMultiUploadedFileInfo(\n                uploadedFile,\n                uploadedDocumentInfo.documentSectionUrls.length - 1\n              );\n            }}\n            mediaValidationRequired={isMediaValidationRequired()}\n            disabled={mode === DOC_UPLOADER_MODE.VIEW}\n          />\n        </div>\n      </div>\n    );\n  };\n\n  const renderAttributeFields = (): ReactNode => {\n    const { selectedDocType } = documentDropdownInfo;\n    const selectedDocAttribute = docAttributeConfigList.find(\n      (item: any) => item.docCode === selectedDocType\n    );\n\n    const generateFieldValidation = (docCode: string, attribute: IAttributeConfig) => {\n      // const validationRules = attribute.required ? \"mandatory\" : \"optional\";\n      const validationRules = \"optional\"; // as per discussions document fields are not mandatory\n      // if (docCode === DOCUMENT_TYPE.PAN) {\n      //   validationRules = validationRules + \"|pan\";\n      //   return validationRules;\n      // } else if (docCode === DOCUMENT_TYPE.AADHAR_CARD) {\n      //   validationRules = validationRules + \"|aadharCard\";\n      //   return validationRules;\n      // } else if (docCode === DOCUMENT_TYPE.PASSPORT) {\n      //   if (attribute.name === INPUT_FIELDS_ATTRIBUTE_NAME.DOB) {\n      //     validationRules = validationRules + \"|dob\";\n      //   }\n      //   return validationRules;\n      // }\n      return validationRules;\n    };\n\n    return (\n      <div className=\"flex\">\n        {/* input fields and validate button */}\n        <div className=\"flex flex-wrap gap-3 items-center\">\n          {selectedDocAttribute?.attributes?.length\n            ? selectedDocAttribute?.attributes?.map((attribute: IAttributeConfig) => (\n                <React.Fragment key={`doc-attribute-${attribute.name}`}>\n                  <div className=\"flex flex-col\">\n                    {attribute.name !== INPUT_FIELDS_ATTRIBUTE_NAME.MASKEDNO && (\n                      <Text\n                        className=\"self-start text-xs select-none\"\n                        label={attribute.label}\n                        // mandatory={attribute.required}\n                      />\n                    )}\n\n                    {attribute.inputType === DOCUMENT_INPUT_FIELDS_TYPE.TEXT ||\n                    attribute.inputType === DOCUMENT_INPUT_FIELDS_TYPE.NUMBER ? (\n                      <Fragment>\n                        {attribute.name !== INPUT_FIELDS_ATTRIBUTE_NAME.MASKEDNO && (\n                          <div className=\"w-61\">\n                            <InputBox\n                              name={`${attribute.name}`}\n                              className=\"!h-6 !py-1 !px-2 focus:outline-0 !focus:border focus:border-secondary-steelBlue-300 outline-0\"\n                              value={uploadedDocumentInfo[`${attribute.name}`]}\n                              onChange={handleInputChange}\n                              onBlur={validate}\n                              validation={validator?.current?.message(\n                                `${attribute.name}`,\n                                uploadedDocumentInfo[`${attribute.name}`],\n                                generateFieldValidation(selectedDocAttribute.docCode, attribute)\n                              )}\n                              hideLabel\n                              disabled={mode === DOC_UPLOADER_MODE.VIEW}\n                            />\n                          </div>\n                        )}\n                      </Fragment>\n                    ) : null}\n\n                    {attribute.inputType === DOCUMENT_INPUT_FIELDS_TYPE.DATE && (\n                      <div className=\"w-61\">\n                        <DatePicker\n                          name=\"dob\"\n                          value={new Date(uploadedDocumentInfo.dob)}\n                          maxDate={new Date()}\n                          variant={INPUT_STYLE_TYPE.SECONDARY}\n                          onChange={handleDateChange}\n                          onBlur={validate}\n                          placeholder=\"DD-MM-YYYY \"\n                          validation={validator?.current?.message(\n                            \"dob\",\n                            uploadedDocumentInfo?.dob,\n                            generateFieldValidation(selectedDocAttribute.docCode, attribute)\n                          )}\n                          hideLabel\n                          disabled={mode === DOC_UPLOADER_MODE.VIEW}\n                        />\n                      </div>\n                    )}\n\n                    {attribute.inputType === DOCUMENT_INPUT_FIELDS_TYPE.SEARCH && (\n                      <div className=\"w-61\">\n                        <AutoComplete\n                          name={`${attribute.name}`}\n                          field={`${attribute.name}`}\n                          variant={INPUT_STYLE_TYPE.PRIMARY}\n                          value={uploadedDocumentInfo[`${attribute.name}`]?.name}\n                          suggestions={suggestionsTemplate}\n                          completeMethod={searchAutocomplete}\n                          onChange={handleAutoCompleteChange}\n                          itemTemplate={itemTempalteAutoComplete}\n                          onBlur={validate}\n                          validation={validator?.current?.message(\n                            `${attribute.name}`,\n                            uploadedDocumentInfo[`${attribute.name}`]?.uid,\n                            generateFieldValidation(selectedDocAttribute.docCode, attribute)\n                          )}\n                          hideLabel\n                          disabled={mode === DOC_UPLOADER_MODE.VIEW}\n                        />\n                      </div>\n                    )}\n                  </div>\n                </React.Fragment>\n              ))\n            : null}\n\n          {false && (\n            <ButtonBox\n              buttonType={BUTTON_TYPE.VALIDATE}\n              className=\"w-36 h-6 text-xs\"\n              label={\"Validate\"}\n              onClickWithLoader={onValidateDocumentType}\n            />\n          )}\n        </div>\n      </div>\n    );\n  };\n\n  const itemTempalteAutoComplete = (item: any) => {\n    if (item.name === undefined || item.name === \"\") {\n      return (\n        <div className=\"flex flex-col items-center justify-center h-39\">\n          <Text className=\"text-primary-labelColor mt-2\" label=\"label.noDataFound\" />\n        </div>\n      );\n    }\n    return (\n      <div className=\"flex flex-col\">\n        <Text className=\"text-primary-labelColor\" label={`${item.name}`} />\n      </div>\n    );\n  };\n\n  /*---------------------------Main Render------------------------------ */\n  return (\n    <div className=\"doc-uploader\">\n      <div className=\"flex flex-col\">\n        {/* render dropdown to select doc type */}\n        <div className=\"w-full flex items-center justify-between\">\n          <div className=\"w-61\">\n            <SimpleDropDown\n              name={\"selectedDocType\"}\n              options={documentDropdownInfo.documentTypeList}\n              optionLabel={\"label\"}\n              optionValue={\"value\"}\n              onChange={handleDocTypeChange}\n              onBlur={mandatoryDocUpload ? validate : undefined}\n              validation={\n                mandatoryDocUpload\n                  ? validator?.current?.message(\n                      \"selectedDocType\",\n                      documentDropdownInfo.selectedDocType,\n                      \"mandatory\"\n                    )\n                  : undefined\n              }\n              value={documentDropdownInfo.selectedDocType}\n              hideLabel\n              disabled={mode === DOC_UPLOADER_MODE.VIEW}\n            />\n          </div>\n\n          {accessKebab && (\n            <div className=\"self-start\">\n              <FileUploadMenuBox model={documentCardMenuOptions} variant=\"SECONDARY\" />\n            </div>\n          )}\n        </div>\n        {/* render uploaders */}\n        <div className=\"flex flex-col gap-2\">\n          {docUploadTypeTitle && (\n            <div className=\"font-thin text-primary-ptext-1000 text-xs\">\n              <Text label={docUploadTypeTitle ?? `Attach Documents (PDF , JPEG or PNG)`} />\n            </div>\n          )}\n          {documentDropdownInfo.selectedDocType\n            ? isMultiSectionMode\n              ? renderMultiSectionUploaders()\n              : renderSectionUploaders()\n            : renderDummyUploader()}\n        </div>\n\n        {/* render if ocr available  */}\n        <div className=\"self-end\">\n          {ocr.showPopulateOcr ? (\n            <IconButton\n              className={`select-none`}\n              buttonType={BUTTON_TYPES.OCR}\n              onClick={() => {\n                onPopulateOCR();\n              }}\n              tooltipOptions={{\n                position: \"top\",\n                className: \"text-xs font-Roboto bg-black text-white !p-1 rounded-md \",\n                showDelay: \"1000,\",\n                hideDelay: \"300\",\n              }}\n              disabled={mode === DOC_UPLOADER_MODE.VIEW}\n            >\n              {loaderOcr && renderLoaderIcon()}\n\n              <Text\n                className={`font-normal text-xs  ${\n                  mode === DOC_UPLOADER_MODE.VIEW\n                    ? \"text-primary-ptext-600 \"\n                    : \"text-primary-sapphireBlue-600 !cursor-pointer\"\n                }`}\n                label={\"label.populate.OCR\"}\n              />\n            </IconButton>\n          ) : (\n            <div className=\"h-5\"></div>\n          )}\n        </div>\n\n        {/* render input fields, ocr validate document button if available in document */}\n        <div>{renderAttributeFields()}</div>\n      </div>\n\n      <ErrorDialog\n        onHide={() => {\n          setShowDialogAPIError(false);\n          setErrorMessage(\"\");\n        }}\n        visible={showDialogAPIError}\n        errorMessage={errorMessage}\n      />\n    </div>\n  );\n});\n\nexport default DocumentUploader;\n"],"names":["DEFAULT_PATH","DocumentCategoryService","BaseApiService","__publicField","start","limit","search","url","DocumentCategoryService$1","DocumentOcrService","payload","DocumentOcrService$1","FILE_UPLOADER_MODE","DOC_UPLOADER_MODE","INPUT_FIELDS_ATTRIBUTE_NAME","DOCUMENT_INPUT_FIELDS_TYPE","DOCUMENT_UPLOAD_CATEGORY_LABEL","initialDocInfo","initialDocSectionUrl","initialOcr","dummySavedDocStructure","dummyOcrResponseStructure","dummySavedDocStructureInList","DocumentUploader","forwardRef","props","ref","mode","queryParamForDocList","docUploadTypeTitle","mandatoryDocUpload","savedDocument","ocrSubstageName","ocrStageName","ocrPayloadData","accessKebab","docUploaderIndex","onRemoveFromList","documentCardMenuOptions","uploadedDocumentInfo","documentDropdownInfo","setDocumentDropdownInfo","useState","docSections","setDocSections","docAttributeConfigList","setDocAttributeConfigList","documentMetaDataOptions","setDocumentMetaDataOptions","setUploadedDocumentInfo","isSavedDocTypeChanged","setIsSavedDocTypeChanged","deletedDocSections","setDeletedDocSections","savedDocSectionsToOveride","setSavedDocSectionsToOveride","isMultiSectionMode","setIsMultiSectionMode","mediaGalleryInfoListInMultiSectionMode","setMediaGalleryInfoListInMultiSectionMode","deletedDocSectionsInMultiFileMode","setDeletedDocSectionsInMultiFileMode","suggestionsTemplate","setSuggestionsTemplate","ocr","setOcr","loaderOcr","setLoaderOcr","ocrStatus","setOcrStatus","ocrData","setOcrData","forceUpdate","validator","useRef","SimpleReactValidator","getStandardValidator","messageReplace","prev","errorMessage","setErrorMessage","showDialogAPIError","setShowDialogAPIError","fileUploaderRef","useEffect","init","_a","selectedDocumentType","document","prepareDocumentSections","prepareDocInfoFromSavedAndRender","documentSectionUrlsCopy","documentSectionUrlsMap","docSection","section","idx","currentDocAttributes","docAttribute","isOcrAvailableInDocType","prepareMediaGalleryInfoList","useImperativeHandle","prepareUploadedData","resetValidator","resetAllStates","useCallback","structDocUrlFromSaved","savedDocSection","selectedDoc","resetIfSavedDocTypeChange","updateSectionsWhenDeleted","index","handleDocTypeChange","e","handleInputChange","handleDateChange","value","handleAutoCompleteChange","event","name","fieldValue","fieldCode","_b","onPopulateOCR","validateAllUploaders","URL_PATH","enrichPopulateOcrInDocUploader","res","validatePostAPIResponse","getSectionsInfo","preparedOcrData","error","parseStandardAPIErrorMessage","validate","validateForm","isValid","currentFileUploaderIdx","_c","uploadStatusListInUploader","metaSelectionListInUploader","_d","val","prepareDocTypeList","getDocTypeList","getSectionList","sections","metaDataOptions","documentSection","DOCUMENT_SECTION","validateGetAPIResponse","documentTypeLists","preparedDocumentList","preparedDocAttrConfigList","findPrimaryKeyAttributeName","attributes","attribute","record","_e","_f","_g","_h","_i","docAttributes","uid","DocumentService","getUploadedFileInfo","uploadedFile","getSavedFileSignedUrl","signedUrl","docSectionUrls","documentUploaderData","getPrimaryAttributeKeyName","documentCode","getDocSectionsUrlsByOveriding","getSavedPreviousSection","docSectionToOveride","savedDocSectionuid","filterUplodedSectionsByUrl","uploadedDocumentProofs","getDocInfoWithAllDeletedSecInMultiSectionMode","allUploaderValidation","onDeleteFromUploader","sectionName","isOcrAvailable","deletedSection","updatedDocumentUrl","doc","uploadedDocInfo","prepareDocSections","documentSections","getSectionSignedUrl","sectionCode","getMultiUploadedFileInfo","getSelectedMeta","metaData","isMediaValidationRequired","DOCUMENT_CATEGORY","onDeleteInMultiFileMode","sortSectionsByName","sortedSections","sectionCodeMap","preparedInfoInList","searchAutocomplete","StaticMasterDataService","renderDummyUploader","jsx","FileUploadCustom","renderLoaderIcon","LoaderIcon","renderSectionUploaders","category","defaultOptions","prepareMediaGalleryInfo","collectedMediaInfo","refValue","renderMultiSectionUploaders","jsxs","renderAttributeFields","selectedDocType","selectedDocAttribute","item","generateFieldValidation","docCode","React","Text","Fragment","InputBox","DatePicker","INPUT_STYLE_TYPE","AutoComplete","itemTempalteAutoComplete","SimpleDropDown","FileUploadMenuBox","IconButton","BUTTON_TYPES","ErrorDialog"],"mappings":"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"}